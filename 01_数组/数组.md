## 数组

### 1 数组理论基础

数组需要注意的是

- **数组下标都是从0开始的。**
- **数组内存空间的地址是连续的**

正是**因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**

所以我们说数组有着**查询，修改容易；删除、添加困难**的特性

---

同时还需要注意的是：**那么二维数组在内存的空间地址是连续的么？**

**C++中二维数组在地址空间上是连续的**。

而在Java中没有指针，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。

所以Java的二维数组可能是如下排列的方式：

<img src="E:\learning\09_leetcode\Leetcode\01_数组\picture\Java二维数组的保存.png" alt="Java二维数组的保存" style="zoom:25%;" />

### 2 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:

```text
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4     
```

示例 2:

```text
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1        
```

提示：

- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间

#### 2.1 二分查找（左闭右闭）

第一种写法，定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] **。

```java
    /**
     * 二分查找（左闭右闭区间）
     * @param Array 有序无重复的数组Array
     * @param target 目标元素target
     * @return 返回目标元素的下表，没有则返回-1
     */
    public int binarySearch(int[] Array, int target){
        int left = 0;
        int right = Array.length - 1;
        while(left <= right){
            int middle = left + ((right - left) / 2);
            if (Array[middle]==target) {
                return middle;
            } else if (Array[middle] > target){
                right = middle - 1;
            } else {
                left = middle + 1;
            }
        }
        return -1;
    }
```

#### 2.2 二分查找（左闭右开）

如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。

```java
    /**
     * 二分查找（左闭右开区间）
     * @param Array 有序无重复的数组Array
     * @param target 目标元素target
     * @return 返回目标元素的下表，没有则返回-1
     */
    public int binarySearch2(int[] Array, int target){
        int left = 0;
        int right = Array.length;
        while(left < right){
            int middle = left + ((right - left)>>1);
            if (Array[middle] == target) return middle;
            else if (Array[middle] > target) right = middle;
            else left = middle + 1;
        }
        return -1;
    }
```

#### 2.3 搜索插入位置 （相关题目）

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

**示例 1:**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2:**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3:**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```


提示:

- 1 <= nums.length <= 104
- -104 <= nums[i] <= 104
- nums 为 无重复元素 的 升序 排列数组
- -104 <= target <= 104

(1) 左闭右闭区间

```java
    public int searchInsert(int[] nums, int target){
        int left = 0;
        int right = nums.length - 1;
        while(left <= right){
            int middle = left + ((right - left)>>1);
            if (nums[middle] > target) {
                right = middle - 1;
            }
            else if (nums[middle] < target) {
                left = middle + 1;
            }
            else return middle;

        }
         return right + 1;
    }
```

(2) 左闭右开区间

```java
    public int searchInsert2(int[] nums, int target) {
        int left = 0;
        int right = nums.length;
        while(left < right){
            int middle = left + ((right - left)>>2);
            if (nums[middle] > target){
                right = middle;
            } else if (nums[middle] < target){
                left = middle + 1;
            } else {
                return middle;
            }
        }
        return left;
    }
```

